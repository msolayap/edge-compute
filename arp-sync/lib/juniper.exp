

# Device specific functions to override base procs - polymorphism
# Device Vendor: Juniper

namespace eval Juniper {


	namespace export \
		init_vars \
		init_terminal \
		get_arp_entries \
		prepare_set_arp_cmd \
		ping_target \
		device_logout 

	proc init_vars {} {
		uplevel {
			set prompt "(%|#|\\\$|>) *$"
			set send_human {.1 .3 1 .05 2}
			set send_slow {2 .001}
			# specific to this piece
			set vendor_detected 0
			set device_vendor "unknown"
			set timeout 30 
			log_user 1 ;
		}
	}

	proc init_terminal {} {
		global prompt

		set scrlen "set cli screen-length 0" ;

		lputs "Initializing Terminal" ;
		send -h "\r" ;
		expect {
			-re $prompt {
				lputs "sending command /$scrlen/" ;
				send "$scrlen\r" ;
			}
		}
		return 0;
	}

# proc to get all arp entries from the current device
	proc get_arp_entries { {arp_filter ""} } {

		set _proc_name [lindex [info level 1 ] 0 ]

		global prompt current_device;

		lputs "fetching arp entries from [dict get $current_device device]"

		set arp_read_completed 0
		set all_arp_dict {} ;
		set all_arp_list {} ;
		set total_arp_found  0
		set arp_output "" ;
		set arp_get_cmd "show arp" ;

		send -s  "\r" ;
		expect {
			-re $prompt {
				if {$arp_read_completed == 0} {
					send "$arp_get_cmd\r" ;
					lputs "sent command: /$arp_get_cmd/" ;
					expect {
						-re "\r?\n?..:..:..:\[^\r]+\r\n" {
							append arp_output $expect_out(0,string) ;
							lputs "Found arp line: $expect_out(0,string)" ;
							exp_continue ;
						}
						#-re "Total\[^\r]+\r?\n$" { }
						-re $prompt {
							lputs "ARP read complete";
						}
						default  { 
						}
						timeout {
							dputs "Show arp ending timedout" 
						}
						eof {
							dputs "EOF occured in $_proc_name" ;
						}

					}
			   } 
			}
		}
#normalize arp output to a list, so each line 
		foreach line [split $arp_output "\n"] {

			set line [string trimright $line];
			set line [string trimleft $line];

			if { [regexp  "^$"  $line] } {
				#dputs ">$line<" ;
				#dputs "invalid arp line. skipping" ;
				continue ;
			}
			set arp_entry "" ;

			if { [ regexp "^(.*?)\[ ]+(.*?)\[ ]+(.*?)\[ ]+(.*?)\[ ]+(.*?)$" $line dummy mac address name iface flags] } { 
# Create a temporary dictionary with field values scanned by regexp
				set arp_entry [dict create mac $mac address $address name $name iface $iface flags $flags]

				if { [regexp "^(.*?)\\.(.*?)$" [dict get $arp_entry iface] dummy iface vlan] } {
					set arp_entry [dict set arp_entry iface_only $iface] ;
					set arp_entry [dict set arp_entry vlan $vlan ];
					set arp_entry [dict set arp_entry unit $vlan ];
				}

				set arp_entry [dict set arp_entry family "inet" ] ;

# Append the ARP entry dict to a master list.
				lappend all_arp_dict $arp_entry 
			}

		}
		return $all_arp_dict ;
	}

	proc prepare_set_arp_cmd {arp_entries_list } {
		set _proc_name [lindex [info level 1 ] 0 ]

		global current_device ;


		set result_list ""
		set set_arp_cmd ""

		set set_arp_fmt  "set interfaces %s unit %s family %s  address %s arp %s  mac %s"

		lputs "preparing set arp commands for device : [dict get $current_device device] " ;

		set ac 0 
		foreach arp_entry $arp_entries_list  {
			dict with arp_entry {
				set set_arp_cmd [format $set_arp_fmt  $iface_only $unit $family $address $address $mac] ;
			}
			unset -nocomplain iface_only unit family address mac
#			dputs ">$set_arp_cmd<" ;

			lappend result_list  $set_arp_cmd ;
			incr ac 1

			set set_arp_cmd ""
		}

		lputs [format "%d set arp commands prepared" $ac]

		return $result_list ;
	}

	proc ping_target {target params} {

		global warn_msg ;

		set _proc_name [lindex [info level 1 ] 0 ]
		dputs [format $warn_msg $_proc_name ]
	}

	proc device_logout {} { 
		global warn_msg ;

		set _proc_name [lindex [info level 1 ] 0 ]
		dputs [format $warn_msg $_proc_name ]
	}
}
