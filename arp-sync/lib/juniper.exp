

# Device specific functions to override base procs - polymorphism
# Device Vendor: Juniper

namespace eval Juniper {


	namespace export \
		init_vars \
		init_terminal \
	    convert_dynamic_arp_to_static \
		device_logout 

	proc init_vars {} {
		uplevel {
			set prompt "(%|#|\\\$|>) *$"
			set send_human {.1 .3 1 .05 2}
			set send_slow {2 .001}
			# specific to this piece
			set vendor_detected 0
			set device_vendor "unknown"
			set timeout 30 
			log_user 1 ;
		}
	}

	proc init_terminal {} {
		global prompt

		set scrlen "set cli screen-length 0" ;

		lputs "Initializing Terminal" ;
		send -h "\r" ;
		expect {
			-re $prompt {
				lputs "sending command /$scrlen/" ;
				send "$scrlen\r" ;
			}
		}
		return 0;
	}

	proc convert_dynamic_arp_to_static {} {

		#set all_arp_dict [get_arp_entries {match "lag"} ]
		set all_arp_dict [get_arp_entries ]

		set non_static_arp_dict [filter_dynamic_arps $all_arp_dict] ;

		lputs "Found [llength $non_static_arp_dict] Dynamic entries out of Total [llength $all_arp_dict] ARP entries" ;

		set set_arp_cmd_list [prepare_set_arp_cmd $non_static_arp_dict]

		return $set_arp_cmd_list ;
	}


	proc filter_dynamic_arps {all_arps} {

		set dynamic_arp_dict {} ;
# Filter Dynamic ARP entries by Type field
		foreach entry $all_arps {
			if { [regexp -nocase "permanent" [dict get $entry flags] ] } {
				continue ;
			} else {
				lappend dynamic_arp_dict $entry 
			}
		}

		return $dynamic_arp_dict ;
	}

# proc to get all arp entries from the current device
	proc get_arp_entries { {arp_filter ""} } {

		set _proc_name [lindex [info level 1 ] 0 ]

		global prompt current_device;

		lputs "fetching arp entries from [dict get $current_device device]"

		set arp_read_completed 0
		set all_arp_dict {} ;
		set all_arp_list {} ;
		set total_arp_found  0
		set arp_output "" ;
		set arp_get_cmd "show arp" ;

		if { [regexp "^.+$" $arp_filter] } {
			lputs "applying arp_filter $arp_filter"
			append arp_get_cmd " | $arp_filter" ;
		}

		send -s  "\r" ;
		expect {
			-re $prompt {
				if {$arp_read_completed == 0} {
					send "$arp_get_cmd\r" ;
					lputs "sent command: /$arp_get_cmd/" ;
					sleep 0.1
					expect {
						-re "\r?\n?..:..:..:\[^\r]+\r\n" {
							append arp_output $expect_out(0,string) ;
							#lputs "Found arp line: $expect_out(0,string)" ;
							exp_continue ;
						}
						#-re "Total\[^\r]+\r?\n$" { }
						-re $prompt {
							lputs "ARP read complete";
						}
						default  { 
						}
						timeout {
							dputs "Show arp ending timedout" 
						}
						eof {
							dputs "EOF occured in $_proc_name" ;
						}

					}
			   } 
			}
		}
# convert all arp lines to dictionary structure for easy processing.
		set all_arp_dict [parse_arp_entries [split $arp_output "\n"]] ;

		return $all_arp_dict ;
	}

	proc is_arp_line_valid {arp_line} {
		set is_valid 1;

		eval set arp_line_fields [list $arp_line ]
		set field_count [llength $arp_line_fields] ;

# Empty line check
		if { [regexp "^$" $arp_line] } { 
			set is_valid 0 ;

		} elseif { $field_count < 5 } {

# is the entry contains all the fields i.e IP MAC EXPIRY Type, Interface
# sometimes MAC may be missing. This check is for that.
			set is_valid 0 ;
		} elseif { ! [regexp  "^(\[0-9A-Za-z]{2}\:){5}" [lindex $arp_line_fields 0] ] } {

# is the line starting with valid IP address
			set is_valid 0;
		}

		return $is_valid 
	}


	proc parse_arp_entries {arp_entries_list}  {

		set arp_entries_dict {}

#normalize arp output to a list, so each line 
		foreach line $arp_entries_list {

			set line [string trim $line];

			dputs "processing $line" ;

			set line_valid  [is_arp_line_valid $line] ;

			if {! $line_valid  } {
				dputs "not valid arp entry"
				continue ;
			}

			set arp_entry "" ;

			if { [ regexp "^(.+?)\[ ]+(.+?)\[ ]+(.+?)\[ ]+(.+?)\[ ]+(.+?)$" $line dummy mac address name iface flags] } { 
				dputs "valid arp entry" ;
# Create a temporary dictionary with field values scanned by regexp
				set arp_entry [dict create mac $mac address $address name $name iface $iface flags $flags]

				if { [regexp "^(.*?)\\.(.*?)$" [dict get $arp_entry iface] dummy iface vlan] } {
					set iface_only $iface
					set vlan $vlan
				} else {
					set iface_only ""
					set vlan ""
				}

				set arp_entry [dict set arp_entry iface_only $iface_only] ;
				set arp_entry [dict set arp_entry vlan $vlan ];
				set arp_entry [dict set arp_entry unit $vlan ];

				set arp_entry [dict set arp_entry family "inet" ] ;

# Append the ARP entry dict to a master list.
				lappend arp_entries_dict $arp_entry 
			}

		}
		return $arp_entries_dict ;
	}


	proc prepare_set_arp_cmd {arp_entries_list } {
		set _proc_name [lindex [info level 1 ] 0 ]

		global current_device ;


		set commit_cmd "commit check" ;
		set result_list ""
		set set_arp_cmd ""

		set set_arp_fmt  "set interfaces %s unit %s family %s  address %s arp %s  mac %s"

		lputs "preparing set arp commands for device : [dict get $current_device device] " ;

		set ac 0 
		foreach arp_entry $arp_entries_list  {
			dict with arp_entry {
				set set_arp_cmd [format $set_arp_fmt  $iface_only $unit $family $address $address $mac] ;
			}
			unset -nocomplain iface_only unit family address mac

			lappend result_list  $set_arp_cmd ;
			incr ac 1

			set set_arp_cmd ""
		}
# Add Commit statements here
		if  { $ac > 0 } {
			lappend result_list $commit_cmd ;
		}

		lputs [format "%d set arp commands prepared" $ac]

		return $result_list ;
	}

	proc ping_target {target params} {

		global warn_msg ;

		set _proc_name [lindex [info level 1 ] 0 ]
		dputs [format $warn_msg $_proc_name ]
	}

	proc device_logout {} { 
		set _proc_name [lindex [info level 1 ] 0 ]
		global current_device ;

		lputs "Exiting from device [dict get $current_device device]" ;
		send "exit\r" ;
	}
}
